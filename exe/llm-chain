#!/usr/bin/env ruby
# frozen_string_literal: true

# Load Bundler only if running from the development repo (Gemfile present)
if File.exist?(File.expand_path("../../Gemfile", __dir__))
  begin
    require "bundler/setup"
  rescue LoadError
    warn "[llm-chain] Bundler not available; continuing without it"
  end
end

require "llm_chain"
require "optparse"
require "readline"

USAGE = <<~TEXT.freeze
  Usage: llm-chain <command> [options]

  Commands:
    chat <prompt>        Send prompt to quick_chain and print response
    repl                Start interactive REPL session
    diagnose             Run system diagnostics
    tools list           List registered tools in the default toolset
    version              Print LLMChain gem version

  Environment variables:
    LLM_CHAIN_DEBUG      Enable verbose diagnostic logs
TEXT

# Exit with usage if no command
if ARGV.empty?
  warn USAGE
  exit 1
end

command = ARGV.shift

case command
when "repl"
  puts "LLMChain REPL â€” type /help for commands, /exit to quit"
  chain = LLMChain.quick_chain

  loop do
    line = Readline.readline("> ", true)
    break if line.nil? || line.strip == "/exit" || line.strip == "/quit"

    case line.strip
    when "/help"
      puts "/exit            Exit REPL\n" \
           "/mem clear       Clear conversation memory\n" \
           "/tools list      List available tools"
      next
    when "/mem clear"
      chain.memory.clear if chain.memory.respond_to?(:clear)
      puts "[memory cleared]"
      next
    when "/tools list"
      if chain.tools.respond_to?(:tools_description)
        puts chain.tools.tools_description
      else
        puts "No ToolManager attached"
      end
      next
    end

    # Empty input => skip
    next if line.strip.empty?

    begin
      response = chain.ask(line)
      puts response
    rescue => e
      warn "Error: #{e.message}"
    end
  end

  puts "Bye!"

when "chat"
  # Collect prompt from remaining args or STDIN
  prompt = if ARGV.empty?
             puts "Enter prompt (end with CTRL+D):"
             STDIN.read
           else
             ARGV.join(" ")
           end
  if prompt.nil? || prompt.strip.empty?
    warn "No prompt provided"
    exit 1
  end

  begin
    chain = LLMChain.quick_chain
    response = chain.ask(prompt)
    puts "\n=== Response ===\n"
    puts response
  rescue Interrupt
    warn "Interrupted"
  rescue => e
    warn "Error: #{e.message}"
    exit 1
  end

when "diagnose"
  LLMChain.diagnose_system

when "tools"
  sub = ARGV.shift
  case sub
  when "list"
    tm = LLMChain::Tools::ToolManager.create_default_toolset
    puts tm.tools_description
  else
    warn "Unknown tools subcommand"; warn USAGE
    exit 1
  end

when "version", "--version", "-v"
  puts LlmChain::VERSION

else
  warn "Unknown command: #{command}"
  warn USAGE
  exit 1
end 